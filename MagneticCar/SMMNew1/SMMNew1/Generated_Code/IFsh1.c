/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : IFsh1.c
**     Project     : SMMNew1-1
**     Processor   : 56F8013VFAE
**     Component   : IntFLASH
**     Version     : Component 02.409, Driver 02.09, CPU db: 2.87.098
**     Compiler    : CodeWarrior DSP C Compiler
**     Date/Time   : 2016-03-01, 17:44, # CodeGen: 0
**     Abstract    :
**         This component "IntFLASH" implements an access to internal FLASH.
**         The component support reading/writing data into FLASH, erasing of
**         selected sector.
**         The component supports events if the write interrupt is supported.
**         The component supports following modes of write operations:
**           - Write - writing without any test.
**           - Destructive write - sector is erased if necessary.
**           - Safe write - user event is invoked to save and resore data
**                          from the current sector.
**         The component requires on-chip FLASH memory (not used/allocated by
**         other components).
**     Settings    :
**         FLASH memory type                 : Program FLASH
**         Memory size                       : 8192 words
**         Sector size                       : 256 words
**         Interrupt service                 : Disabled
**         Write method                      : Safe write (with save & erase)
**         Buffer Type                       : Implemented by the component
**         Wait in RAM                       : yes
**     Contents    :
**         Busy         - bool IFsh1_Busy(byte Block);
**         SetByteFlash - byte IFsh1_SetByteFlash(IFsh1_TAddress Addr, byte Data);
**         SetWordFlash - byte IFsh1_SetWordFlash(IFsh1_TAddress Addr, word Data);
**         DataPtr2Addr - IFsh1_TAddress IFsh1_DataPtr2Addr(void* Addr);
**         FuncPtr2Addr - IFsh1_TAddress IFsh1_FuncPtr2Addr(void(*Addr)());
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file IFsh1.c
** @version 02.09
** @brief
**         This component "IntFLASH" implements an access to internal FLASH.
**         The component support reading/writing data into FLASH, erasing of
**         selected sector.
**         The component supports events if the write interrupt is supported.
**         The component supports following modes of write operations:
**           - Write - writing without any test.
**           - Destructive write - sector is erased if necessary.
**           - Safe write - user event is invoked to save and resore data
**                          from the current sector.
**         The component requires on-chip FLASH memory (not used/allocated by
**         other components).
*/         
/*!
**  @addtogroup IFsh1_module IFsh1 module documentation
**  @{
*/         
/* MODULE IFsh1. */

#include "IFsh1.h"

/* Registers for usage in asm macros/functions */
#define FMCMD_ASM X:62484
#define FMCR_ASM X:62465
#define FMUSTAT_ASM X:62483

static byte Err;                       /* Error state of current process */

static word BackupArray[PROG_FLASH_SECTOR_SIZE]; /* Array for backup data from erased sector */

/*
** ===================================================================
**     Method      :  IFsh1_OutOfRange (component IntFLASH)
**
**     Description :
**         The method returns FALSE, if both of the input parameters are 
**         in an allowed flash memory address range. If at least one of 
**         the parameters is out of the range, return TRUE.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte OutOfRange(IFsh1_TAddress addr1,IFsh1_TAddress addr2)
{
  return ((addr1>addr2)||(addr1<PROG_FLASH_START)||(addr2>PROG_FLASH_END));
}

/*
** ===================================================================
**     Method      :  IFsh1_BackupArrayAddr (component IntFLASH)
**
**     Description :
**         The method converts a flash memory address to an address in 
**         the backup array for saving the data before erasing a sector 
**         in Save write mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define BackupArrayAddr(addr) (addr & 255)

/*
** ===================================================================
**     Method      :  IFsh1_SectorSize (component IntFLASH)
**
**     Description :
**         The method returns flash memory sector (erase page) size of a 
**         desired area.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define SectorSize(addr) (PROG_FLASH_SECTOR_SIZE)

/*
** ===================================================================
**     Method      :  ClearFlags (component IntFLASH)
**
**     Description :
**         The method clears the flash memory interface complete and 
**         error flags.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define ClearFlags() setReg(FMUSTAT,0x30)

/*
** ===================================================================
**     Method      :  readflash (component IntFLASH)
**
**     Description :
**         The method reads 16-bit word from a flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static asm word readflash(IFsh1_TAddress address)
{
  move.l A10,R2;                       /* Move given address to pointer register */
  move.w p:(r2)+,y0;                   /* Read data from program memory */
  rts;
}

/*
** ===================================================================
**     Method      :  writeflash (component IntFLASH)
**
**     Description :
**         The method writes 16-bit word to a flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static asm word writeflash(IFsh1_TAddress address, word data)
{
  move.l A10,R2;                       /* Move given address to pointer register */
  move.w Y0,p:(R2)+;                   /* Write given data to desired address in program memory */
  rts;
}

/*
** ===================================================================
**     Method      :  Run_and_wait_in_prog_flash (component IntFLASH)
**
**     Description :
**         This method runs programming or erasing process end waits 
**         until it ends. This routine is placed in program flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#pragma define_section RAW_PROG_FLASH_section ".RAW_PROG_FLASH" RX
#pragma section RAW_PROG_FLASH_section begin
static asm void Run_and_wait_in_prog_flash(IFsh1_TAddress address, word data, word command)
{
  move.l A10,R2;                       /* Move given address to pointer register */
  move.w Y0,p:(R2)+;                   /* Write data to the address in program memory */
  move.w Y1,FMCMD_ASM;
  move.w #$80,FMUSTAT_ASM;
wait:
  moveu.w #$f020,R0;
  adda #$3f3,R0,R0;
  move.w X:(R0),A;
  bftstl #$40,A1;
  bcs wait;
  rts;
}
#pragma section RAW_PROG_FLASH_section end

/*
** ===================================================================
**     Method      :  Run_and_wait_in_RAM (component IntFLASH)
**
**     Description :
**         This method runs programming or erasing process end waits 
**         until it ends. This routine is placed in RAM.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#pragma define_section RAW_RAM_section ".RAW_RAM" RWX
#pragma section RAW_RAM_section begin
static asm void Run_and_wait_in_RAM(IFsh1_TAddress address, word data, word command)
{
  move.l A10,R2;                       /* Move given address to pointer register */
  move.w Y0,p:(R2)+;                   /* Write data to the address in program memory */
  move.w Y1,FMCMD_ASM;
  move.w #$80,FMUSTAT_ASM;
wait:
  moveu.w #$f020,R0;
  adda #$3f3,R0,R0;
  move.w X:(R0),A;
  bftstl #$40,A1;
  bcs wait;
  rts;
}
#pragma section RAW_RAM_section end

/*
** ===================================================================
**     Method      :  mempcpy (component IntFLASH)
**
**     Description :
**         The methods makes a copy of a program memory block (both 
**         source and destination address is in a program memory). It is 
**         used for copying the WIR_routine / Run_and_wait_in_RAM routine 
**         to RAM after system reset.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static asm void mempcpy(IFsh1_TAddress source_addr, IFsh1_TAddress dest_addr, word size)
{
    move.w  y0,r2                      /* set data size */
    move.l  a10,r3                     /* src address */
    move.l  b10,r1                     /* dest address */
    do      r2,>>end_prom2pram         /* copy for r2 times */
    move.w  p:(r3)+,x0                 /* fetch value at address r3 */
    nop
    nop
    nop
    move.w  x0,p:(r1)+                 /* stash value at address r1 */
    nop
    nop
    nop
end_prom2pram:
    rts;
}

/*
** ===================================================================
**     Method      :  procflash (component IntFLASH)
**
**     Description :
**         The method programs 16-bit word to a flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte procflash(IFsh1_TAddress address, word data, word command)
{
  if (IFsh1_Busy())                    /* Is a command in progress in any of the flash devices? */
    return ERR_BUSY;                   /* If yes then error */
  ClearFlags();                        /* Clear all flags */
  EnterCritical();                     /* Disable all low level interrupts */
  Run_and_wait_in_RAM(address,data,command); /* Process routine in RAM */
  ExitCritical();                      /* Enable all low level interrupts */
  if ((getRegBit(FMUSTAT,PVIOL))||(getRegBit(FMUSTAT,ACCERR))) /* Is protection violation or access error detected ? */
    return ERR_NOTAVAIL;               /* If yes then return the error */
  return Err;
}

/*
** ===================================================================
**     Method      :  BackupSector (component IntFLASH)
**
**     Description :
**         The method backups data from a sector, which is to be erased 
**         in the Save write mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void BackupSector(IFsh1_TAddress Addr)
{
  register word i;
  register IFsh1_TAddress StartAddress;
  StartAddress = Addr & ~((IFsh1_TAddress)(SectorSize(Addr)-1)); /* Calculate start of the sector */
  for (i=SectorSize(Addr); i>0;) {     /* For all words in the sector */
    i--;                               /* array pointer */
    BackupArray[i] = readflash((StartAddress+i)); /* save word to buffer in data RAM */
  }
}

/*
** ===================================================================
**     Method      :  RestoreSector (component IntFLASH)
**
**     Description :
**         The method restores data to a sector, which has been erased in 
**         the Save write mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte RestoreSector(IFsh1_TAddress Addr)
{
  register word i=0;
  register IFsh1_TAddress StartAddress;
  StartAddress = Addr & ~((IFsh1_TAddress)(SectorSize(Addr)-1)); /* Calculate start of the sector */
  for (i = SectorSize(Addr); i>0;) {   /* For all words in the sector */
    i--;                               /* Decrease array pointer, write word to FLASH */
    Err = procflash((StartAddress+i),BackupArray[i],PROGRAM);
    if (Err!=ERR_OK)                   /* If an error uccure then exit */
      return Err;
    while (getRegBit(FMUSTAT,CBEIF) == 0) {} /* Wait to buffer empty */
  }
  while (getRegBit(FMUSTAT,CCIF) == 0) {} /* Wait to command complete */
  for (i = SectorSize(Addr); i>0;) {   /* For all words in the sector */
    i--;                               /* Decrease array pointer, write word to FLASH */
    if (readflash((StartAddress+i)) != BackupArray[i]) /* Are the written data equal to read data ? */
      return ERR_VALUE;                /* If no then error */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  IFsh1_Busy (component IntFLASH)
*/
/*!
**     @brief
**         This method returns the status of the FLASH device. The
**         method may be required and called from another component
**         methods - in this case it cannot be disabled.
**     @param
**         Block           - Number of Flash block. Not used for
**                           Freescale 56800, HCS08, HCS12X and
**                           ColdFireV1 derivates - any value may be
**                           passed.
**     @return
**                         - [true]/[false] - FLASH is busy/ready
*/
/* ===================================================================*/
/*
bool IFsh1_Busy(byte Block)

**      This method is implemented as macro. See IFsh1.h file.      **
*/

/*
** ===================================================================
**     Method      :  IFsh1_SetByteFlash (component IntFLASH)
*/
/*!
**     @brief
**         Writes a byte to an address in FLASH. The operation of this
**         method depends on the "Write method" property and state of
**         the flash. Please see more details on general info page of
**         the help.
**     @param
**         Addr            - Address to FLASH.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The value of this parameter is address of a
**                           byte location in the selected memory space
**                           (address of a 16 bit word location
**                           multiplied by 2 and the least significant
**                           bit determines even or odd byte). The
**                           memory space depends on the selected flash
**                           memory device.
**     @param
**         Data            - Data to write.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - Address is out of range 
**                           - ERR_VALUE - Read value is not equal to
**                           written value 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode 
**                           - ERR_BUSY - Device is busy 
**                           - ERR_PROTECT - Flash is write protect
*/
/* ===================================================================*/
byte IFsh1_SetByteFlash(IFsh1_TAddress Addr,byte Data)
{
  word Data16;
  register IFsh1_TAddress Addr16;
  Err = ERR_OK;
  Addr16 = Addr/2;                     /* Determine WORD16 address */
  if (OutOfRange(Addr16,Addr16))       /* Check range of address */
    return ERR_RANGE;
  Data16 = readflash(Addr16);          /* Determine data to write */
  *((byte*)(&Data16)+Addr%2) = Data;
  if (~(readflash(Addr16))&Data16) {   /* Is a sector erasure necessary? */
    BackupSector(Addr16);              /* Backup sector */
    Err = procflash(Addr16,0,PAGE_ERASE); /* Erase sector */
    if (Err!=ERR_OK) {                 /* If an error occured then exit */
      return Err;
    }
    while (getRegBit(FMUSTAT,CBEIF) == 0) {} /* Wait to buffer empty */
    BackupArray[BackupArrayAddr(Addr16)] = Data16; /* Write new data to saved sector */
    Err = RestoreSector(Addr16);       /* Restore sector */
    if (Err != ERR_OK) {               /* If an error occured then exit */
      return Err;
    }
  }
  else {
    Err = procflash(Addr16, Data16, PROGRAM); /* Write new data to Flash */
  }
  while (getRegBit(FMUSTAT,CCIF) == 0) {} /* Wait to command complete */
  if (Err==0) {
    if (readflash(Addr16) != Data16) { /* If the read data are not equal to the written data then error */
      return ERR_VALUE;
    }
  }
  return Err;
}

/*
** ===================================================================
**     Method      :  IFsh1_SetWordFlash (component IntFLASH)
*/
/*!
**     @brief
**         Writes a word to an address in FLASH. The operation of this
**         method depends on the "Write method" property and state of
**         the flash. Please see more details on general info page of
**         the help.
**     @param
**         Addr            - Address to FLASH.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The value of this parameter is address of a
**                           16 bit word location in the selected memory
**                           space. The memory space depends on the
**                           selected flash memory device.
**     @param
**         Data            - Data to write.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - Address is out of range 
**                           - ERR_VALUE - Read value is not equal to
**                           written value 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode 
**                           - ERR_BUSY - Device is busy 
**                           - ERR_PROTECT - Flash is write protect
*/
/* ===================================================================*/
byte IFsh1_SetWordFlash(IFsh1_TAddress Addr,word Data)
{
  Err = ERR_OK;
  if (OutOfRange(Addr,Addr))            /* Check range of address */
    return(ERR_RANGE);
  if (~(readflash(Addr))&Data) {       /* Is a sector erasure necessary? */
    BackupSector(Addr);                /* Backup sector */
    Err = procflash(Addr,0,PAGE_ERASE); /* Erase sector */
    if (Err!=ERR_OK) {                 /* If an error occured then exit */
      return Err;
    }
    while (getRegBit(FMUSTAT,CBEIF) == 0) {} /* Wait to buffer empty */
    BackupArray[BackupArrayAddr(Addr)] = Data; /* Write new data to saved sector */
    Err = RestoreSector(Addr);         /* Restore sector */
    if (Err != ERR_OK) {               /* If an error occured then exit */
      return Err;
    }
  }
  else {
    Err = procflash(Addr, Data, PROGRAM); /* Write new data to Flash */
  }
  while (getRegBit(FMUSTAT,CCIF) == 0) {} /* Wait to command complete */
  if (Err==0) {
    if (readflash(Addr) != Data) {     /* If the read data are not equal written data then error */
      return ERR_VALUE;
    }
  }
  return Err;
}

/*
** ===================================================================
**     Method      :  IFsh1_Init (component IntFLASH)
**
**     Description :
**         Initializes the associated peripheral(s) and the beans 
**         internal variables. The method is called automatically as a 
**         part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void IFsh1_Init(void)
{
/* Copy FLASH process routine to program RAM. All program or erase processes will be launched and wait for their end in this routine */
  mempcpy(((dword)&_LWIR_ROM_addr_high<<16)+(dword)&_LWIR_ROM_addr_low, ((dword)&_LWIR_RAM_addr_high<<16)+(dword)&_LWIR_RAM_addr_low, (word)(dword)&_LWIR_size);
}

/*
** ===================================================================
**     Method      :  IFsh1_DataPtr2Addr (component IntFLASH)
*/
/*!
**     @brief
**         This method converts data pointer to format of a component's
**         method address parameter. Generally a data pointer format is
**         different from format of a method Addr parameter.
**     @param
**         Addr            - Data pointer.
**     @return
**                         - Address in the format used in the component
**                           methods.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The return value is address of a byte
**                           location of the object the input parameter
**                           - pointer pointing at (address of a 16 bit
**                           word location multiplied by 2 and the least
**                           significant bit determines even or odd byte).
*/
/* ===================================================================*/
/*
IFsh1_TAddress IFsh1_DataPtr2Addr(void DataPtr)

**  This method is implemented as a macro. See IFsh1.h file.  **
*/

/*
** ===================================================================
**     Method      :  IFsh1_FuncPtr2Addr (component IntFLASH)
*/
/*!
**     @brief
**         This method converts function pointer to format of a
**         component's method address parameter. Generally a function
**         pointer format is different from format of a method Addr
**         parameter.
**     @param
**         Addr            - Function pointer.
**     @return
**                         - Address in the format used in the component
**                           methods.
**                           [ Version specific information for 56800
**                           derivatives ] 
**                           The return value is address of a byte
**                           location of the object the input parameter
**                           - pointer pointing at (address of a 16 bit
**                           word location multiplied by 2 and the least
**                           significant bit determines even or odd byte).
*/
/* ===================================================================*/
/*
IFsh1_TAddress IFsh1_FuncPtr2Addr(void FuncPtr)

**  This method is implemented as a macro. See IFsh1.h file.  **
*/

/* END IFsh1. */
/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale 56800 series of microcontrollers.
**
** ###################################################################
*/
